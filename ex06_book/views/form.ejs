<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>책 수정</title>
  <link rel="stylesheet" href="../stylesheets/style.css">
</head>
<body>
  <h1>책 수정</h1>
  <!-- form method = GET/POST -->
  <!-- form + fetch (비동기 요청) -->
  <form id="update-form">
    <input type="text" id="title" value="<%=book.title%>" required>
    <input type="text" id="author" value="<%=book.author%>" required>
    <button type="submit">수정</button>
  </form>

  <script>
    // title, author 수정 후에 수정 버튼(submit)을 누름 → 이벤트(submit) 발생 여부 확인 필요
    const form = document.getElementById('update-form');

    form.addEventListener('submit', async (e) => { // e: event 객체
      // submit 이벤트가 발생하면 무조건 작성되어 있는 값을 서버로 바로 제출함(동기 방식 → GET 요청)
      // → submit 이벤트를 처리하지 않도록 일단 막아줘야 함
      e.preventDefault(); // submit 이벤트 기본 동작 막기

      // 수정된 title, author 값을 가지고 옴
      const title = document.getElementById('title').value; // 실제 사용자가 작성한 값 (input)
      const author = document.getElementById('author').value;

      // GET / DELETE (편지 봉투와 유사) → HEAD에 데이터가 포함됨 (URL에 포함해줌)
      // POST/PATCH/PUT (박스) → BODY에 데이터가 포함됨 (+ HEAD 데이터의 형식, 인코딩 방식 등)
      // fetch : 요청 데이터 (json(객체))
      // [PUT]localhost:3000/books/1(id)
      const res = await fetch(`/books/<%=book.id%>`,{
        method : 'PUT', // HTTP method
        // JS 객체 → 하지만 실제로는 문자열로 변환해서 보내야 함 | 이는 서버측도 동일
        // JSON → String (JSON 형식을 유지)
        body : JSON.stringify({ title, author }),
        headers : {
          'Content-Type' : 'application/json' // JSON 형식으로 보낼 것임을 명시
        }
      });

      // 
      if (res.ok){ // 응답 상태 코드가 200(ok)일 경우에 아래 코드 수행
        // 알림창으로 수정 성공 출력 → index.ejs로 이동 (/books로 요청)
        alert('수정 성공!');
        location.href = '/books'; // /books로 GET 방식으로 요청
      }
    });
  </script>
</body>
</html>
